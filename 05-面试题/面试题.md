## 面试题及答案

- 基础题

  - 关于类型转换，下面语法正确的是（）单选

    ~~~go
    A.
    type MyInt i
    int var i int = 1
    var j MyInt = I
    B.
    type MyInt int
    var i int = 1
    var j MyInt = (MyInt)i string(x)
    C.
    type MyInt int
    var i int = 1
    var j MyInt = MyInt(i)
    D.
    type MyInt int
    var i int = 1
    var j MyInt = i.(MyInt)
    ~~~

  - 阅读一下代码，写出输出结果（）单选

    ~~~go
    func main(){
        var a int = 10
        fmt.Println(a)
        {
            a := 9
            fmt.Println(a)
            a = 8
        }
        fmt.Println(a)
    }
    A.10 10 10
    B.10 9 9
    C.10 9 10
    D.10 9 8
    ~~~

  - 下面程序的运行结果是（）单选

    ~~~go
    func main(){
        if (true){
            defer fmt.Printf("1")
        } else {
            defer fmt.Printf("2")
        }
        fmt.Print("3")
    }
    A.321
    B.32
    C.31
    D.13
    ~~~

  - 关于函数声明，下面语法错误的是（）单选

    ~~~go
    A.func f(a,b int) (value int, err error)
    B.func f(a int,b int) (value int, err error)
    C.func f(a,b int) (value int, error)
    D.func f(a int,b int) (int, int, error)
    ~~~

  - 关于无缓冲和有缓冲的channel，下面说法正确的是（）单选

    ~~~go
    A.无缓冲的channel是默认的缓冲为1的channel
    B.无缓冲的channel和有缓冲的channel都是同步的
    C.无缓冲的channel和有缓冲的channel都是非同步的
    D.无缓冲的channel是同步的，有缓存的channel是非同步的
    ~~~

  - 以下代码，最终输出的结果是什么（）单选

    ~~~go
    type student struct{
        Name string
        Age int
    }
    
    func main(){
        m := make(map[string]*student)
        stus := []student{
            {Name: "zhou", Age:24},
            {Name: "li", Age:23},
            {Name: "wange", Age:22},
        }
        for _,stu := range stus{
            m[stu.Name = &stu
        }
        for _,v := range m{
            fmt.Println(v.Name, " ", v.Age)
        }
    }
    A.
    zhou 24
    li   23
    wang 22
    
    B.
    wang 22
    wang 22
    wang 22
    
    C.
    zhou 24
    zhou 24
    zhou 24
    
    D.
    wang 22
    li   23
    li   23
    ~~~

  - 下面属于go语言的关键字是（）多选

    ~~~
    A.func
    B.def
    C.struct
    D.class
    ~~~

  - 定义一个包内全局字符串变量，下面语法正确的是（）多选

    ~~~
    A.var str string
    B.str := ""
    C.str = ""
    D.var str = ""
    ~~~

  - 通过指针变量p访问其成员变量name，下面语法正确的是（）多选

    ~~~
    A.p.name
    B.(*p).name
    C.(&p).ma,e
    D.p->name
    ~~~

  - 关于接口类的说法，下面说法正确的是（）多选

    ~~~
    A.一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口
    B.实现类时只需要关心自己应该实现哪些方法即可
    C.类实现接口时，需要导入接口所在的包
    D.接口由使用方按自身需求来定义，使用方无需关心接口具体如何实现的
    ~~~

  - 关于字符串连接，下面说法正确的是（）多选

    ~~~
    A.str:='abc'+'123'
    B.str:="abc"+"123"
    C.str : = '123'+"abc"
    D.fmt.Sprintf("abc%d,123)
    ~~~

    

  - 关于协程，下面说法正确的是（）多选

    ~~~
    A.协程和线程都可以实现程序的并发执行
    B.线程比协程更轻量级
    C.协程不存在死锁问题
    D.通过channel来进行协程间的通信
    ~~~

    

  - 关于init函数，下面说法正确的是（）多选

    ~~~
    A.一个包中，可以包含多个init函数
    B.程序编译时，先执行导入包的init函数，再执行本包内的init函数
    C.main包中，不能有init函数
    D.init函数可以被其它函数调用
    ~~~

    

  - 关于循环语句，下面说法正确的是（）多选

    ~~~
    A.循环语句既支持for关键字，也支持while和do-while
    B.关键字for的基本使用方法与C/C++中没有任何差异
    C.for循环支持continue和break来控制循环，但是它提供了一个更高级的label，可以选择终端哪个循环
    D.for循环不支持以逗号为间隔的多个赋值语句
    ~~~

    

  - 对于变量声明下面那些是错误的（）多选

    ~~~
    A.var 2abc string
    B.姓名 := "小明"
    C.var a$b int=123
    D.var func int
    ~~~

    

  - 关于局部变量的初始化，下面正确的使用方式是（）多选

    ~~~
    A.var i int = 10
    B.var i = 10
    C.i := 10
    D.i = 10
    ~~~

    

  - 对add函数调用正确的是（）多选

    ~~~
    func add(args ...int) int {
        sum := 0
        for _,arg := range args {
            sum += arg
        }
        return sum
    }
    
    A.add(1,2)
    B.add(1,3,7)
    C.add([]int{1,2})
    D.add([]int{1,3,7}...)
    ~~~

    

  - 关于switch语句，下面说法正确的有（）多选

    ~~~
    A.条件表达式必须为常量或者整数
    B.switch中，可以出现多个条件相同的case
    C.需要用break来明细退出一个case
    D.只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case
    ~~~

    

  - golang中的引用类型包括（）多选

    ~~~
    A.切片
    B.map
    C.channel
    D.interface
    ~~~

    

  - golang中的指针运算包括（）多选

    ~~~
    A.可以对指针进行自增或自减运算
    B.可以通过“&”取指针的地址
    C.可以通过“*”取指针指向的数据
    D.可以对指针进行下标运算
    ~~~

    

  - 

- 

go程序初始化顺序

### 答案

main包—>import—>全局const—>全局var—>Init()—>main()

如果在import的时候跳到了其它包，则在其它包也是按以上顺序执行完再跳回来

